<html><script type="text/javascript">
    var spector;
    var captureOnLoad = false;
    var captureOffScreen = false;
    window.__SPECTOR_Canvases = [];

    (function() {
        var __SPECTOR_Origin_EXTENSION_GetContext = HTMLCanvasElement.prototype.getContext;
        HTMLCanvasElement.prototype.__SPECTOR_Origin_EXTENSION_GetContext = __SPECTOR_Origin_EXTENSION_GetContext;

        if (typeof OffscreenCanvas !== 'undefined') {
            var __SPECTOR_Origin_EXTENSION_OffscreenGetContext = OffscreenCanvas.prototype.getContext;
            OffscreenCanvas.prototype.__SPECTOR_Origin_EXTENSION_OffscreenGetContext = __SPECTOR_Origin_EXTENSION_OffscreenGetContext;

            OffscreenCanvas.prototype.getContext = function () {
                var context = null;
                if (!arguments.length) {
                    return context;
                }
    
                if (arguments.length === 1) {
                    context = this.__SPECTOR_Origin_EXTENSION_OffscreenGetContext(arguments[0]);
                    if (context === null) {
                        return context;
                    }
                }
                else if (arguments.length === 2) {
                    context = this.__SPECTOR_Origin_EXTENSION_OffscreenGetContext(arguments[0], arguments[1]);
                    if (context === null) {
                        return context;
                    }
                }
    
                var contextNames = ["webgl", "experimental-webgl", "webgl2", "experimental-webgl2"];
                if (contextNames.indexOf(arguments[0]) !== -1) {
                    // context.canvas.setAttribute("__spector_context_type", arguments[0]);
                    // Notify the page a canvas is available.
                    var myEvent = new CustomEvent("SpectorWebGLCanvasAvailableEvent");
                    document.dispatchEvent(myEvent);
                    this.id = "Offscreen";
                    window.__SPECTOR_Canvases.push(this);
    
                    if (captureOnLoad) {
                        // Ensures canvas is in the dom to capture the one we are currently tracking.
                        if (false) {
                            spector.captureContext(context, 500, false, false);
                            captureOnLoad = false;
                        }
                    }
                }
    
                return context;
            }
        }

        HTMLCanvasElement.prototype.getContext = function () {
            var context = null;
            if (!arguments.length) {
                return context;
            }

            if (arguments.length === 1) {
                context = this.__SPECTOR_Origin_EXTENSION_GetContext(arguments[0]);
                if (context === null) {
                    return context;
                }
            }
            else if (arguments.length === 2) {
                context = this.__SPECTOR_Origin_EXTENSION_GetContext(arguments[0], arguments[1]);
                if (context === null) {
                    return context;
                }
            }

            var contextNames = ["webgl", "experimental-webgl", "webgl2", "experimental-webgl2"];
            if (contextNames.indexOf(arguments[0]) !== -1) {
                context.canvas.setAttribute("__spector_context_type", arguments[0]);
                // Notify the page a canvas is available.
                var myEvent = new CustomEvent("SpectorWebGLCanvasAvailableEvent");
                document.dispatchEvent(myEvent);

                if (captureOffScreen) {
                    var found = false;
                    for (var i = 0; i < window.__SPECTOR_Canvases.length; i++) {
                        if (window.__SPECTOR_Canvases[i] === this) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        window.__SPECTOR_Canvases.push(this);
                    }
                }

                if (captureOnLoad) {
                    // Ensures canvas is in the dom to capture the one we are currently tracking.
                    if (this.parentElement || false) {
                        spector.captureContext(context, 500, false, false);
                        captureOnLoad = false;
                    }
                }
            }

            return context;
        }
    })()</script><head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="Generator" content="Microsoft Word 98">
<title>List of Oberon Errors and Warnings</title>
</head>
<body>

<b><font face="Geneva"><p>List of Oberon Errors and Warnings</p>
</font></b><font face="Times">
</font><font face="Geneva"><p>Niklaus Wirth, Régis Crelier, Michael Franz, Thomas Kistler / 20.11.95</p>

<p>&nbsp;</p>
<b><p>1.  Incorrect Use of Language Oberon</p>
</b></font><font face="Times">
</font><font face="Geneva"><p>  0	undeclared identifier</p>
<p>  1	multiply defined identifier</p>
<p>  2	illegal character in number</p>
<p>  3	illegal character in string</p>
<p>  4	identifier does not match procedure name</p>
<p>  5	comment not closed</p>
<p>  9	"=" expected</p>
<p>12	type definition starts with incorrect symbol</p>
<p>13	factor starts with incorrect symbol</p>
<p>14	statement starts with incorrect symbol</p>
<p>15	declaration followed by incorrect symbol</p>
<p>16	MODULE expected</p>
<p>18	"." missing</p>
<p>19	"," missing</p>
<p>20	":" missing</p>
<p>22	")" missing</p>
<p>23	"]" missing</p>
<p>24	"}" missing</p>
<p>25	OF missing</p>
<p>26	THEN missing</p>
<p>27	DO missing</p>
<p>28	TO missing</p>
<p>30	"(" missing</p>
<p>34	":=" missing</p>
<p>35	"," or OF expected</p>
<p>38	identifier expected</p>
<p>39	";" missing</p>
<p>41	END missing</p>
<p>44	UNTIL missing</p>
<p>46	EXIT not within loop statement</p>
<p>47	illegally marked identifier</p>
<p>50	expression should be constant</p>
<p>51	constant not an integer</p>
<p>52	identifier does not denote a type</p>
<p>53	identifier does not denote a record type</p>
<p>54	result type of procedure is not a basic type</p>
<p>55	procedure call of a function</p>
<p>56	assignment to non_variable</p>
<p>57	pointer not bound to record or array type</p>
<p>58	recursive type definition</p>
<p>59	illegal open array parameter</p>
<p>60	wrong type of case label</p>
<p>61	inadmissible type of case label</p>
<p>62	case label defined more than once</p>
<p>63	illegal value of constant</p>
<p>64	more actual than formal parameters</p>
<p>65	fewer actual than formal parameters</p>
<p>66	element types of actual array and formal open array differ</p>
<p>67	actual parameter corresponding to open array is not an array</p>
<p>68	control variable must be integer</p>
<p>69	parameter must be an integer constant</p>
<p>70	pointer or VAR record required as formal receiver</p>
<p>71	pointer expected as actual receiver</p>
<p>72	procedure must be bound to a record of the same scope</p>
<p>73	procedure must have level 0</p>
<p>74	procedure unknown in base type</p>
<p>75	invalid call of base procedure</p>
<p>76	this variable (field) is read only</p>
<p>77	object is not a record</p>
<p>78	dereferenced object is not a variable</p>
<p>79	indexed object is not a variable</p>
<p>80	index expression is not an integer</p>
<p>81	index out of specified bounds</p>
<p>82	indexed variable is not an array</p>
<p>83	undefined record field</p>
<p>84	dereferenced variable is not a pointer</p>
<p>85	guard or test type is not an extension of variable type</p>
<p>86	guard or testtype is not a pointer</p>
<p>87	guarded or tested variable is neither a pointer nor a VAR_parameter record</p>
<p>88	open array not allowed as variable, record field or array element</p>
<p>92	operand of IN not an integer, or not a set</p>
<p>93	set element type is not an integer</p>
<p>94	operand of &amp; is not of type BOOLEAN</p>
<p>95	operand of OR is not of type BOOLEAN</p>
<p>96	operand not applicable to (unary) +</p>
<p>97	operand not applicable to (unary) -</p>
<p>98	operand of ~ is not of type BOOLEAN</p>
<p>99	ASSERT fault</p>
<p>100	incompatible operands of dyadic operator</p>
<p>101	operand type inapplicable to *</p>
<p>102	operand type inapplicable to /</p>
<p>103	operand type inapplicable to DIV</p>
<p>104	operand type inapplicable to MOD</p>
<p>105	operand type inapplicable to +</p>
<p>106	operand type inapplicable to -</p>
<p>107	operand type inapplicable to = or #</p>
<p>108	operand type inapplicable to relation</p>
<p>109	overriding method must be exported</p>
<p>110	operand is not a type</p>
<p>111	operand inapplicable to (this) function</p>
<p>112	operand is not a variable</p>
<p>113	incompatible assignment</p>
<p>114	string too long to be assigned</p>
<p>115	parameter doesn't match</p>
<p>116	number of parameters doesn't match</p>
<p>117	result type doesn't match</p>
<p>118	export mark doesn't match with forward declaration</p>
<p>119	redefinition textually precedes procedure bound to base type</p>
<p>120	type of expression following IF, WHILE, UNTIL or ASSERT is not BOOLEAN</p>
<p>121	called object is not a procedure (or is an interrupt procedure)</p>
<p>122	actual VAR_parameter is not a variable</p>
<p>123	type of actual parameter is not identical with that of formal VAR_parameter</p>
<p>124	type of result expression differs from that of procedure</p>
<p>125	type of case expression is neither INTEGER nor CHAR</p>
<p>126	this expression cannot be a type or a procedure</p>
<p>127	illegal use of object</p>
<p>128	unsatisfied forward reference</p>
<p>129	unsatisfied forward procedure</p>
<p>130	WITH clause does not specify a variable</p>
<p>131	LEN not applied to array</p>
<p>132	dimension in LEN too large or negative</p>
<p>135	SYSTEM not imported</p>
<p>136	SYSTEM must not be imported by portable modules</p>
<p>140	Oberon(-1) language supports dynamic arrays only in parameter lists</p>
<p>141	imported module exports dynamic array</p>
<p>142	Oberon(-1) language does not support type_bound procedures</p>
<p>143	imported module exports type_bound procedure</p>
<p>150	key inconsistency of imported module</p>
<p>151	incorrect symbol file</p>
<p>152	symbol file of imported module not found</p>
<p>154	recursive import not allowed</p>
<p>155	generation of new symbol file not allowed</p>

<p>&nbsp;</p>
<b><p>2.  Limitations of MacOberon Implementation</p>
</b></font><font face="Times">
</font><font face="Geneva"><p>200	not yet implemented</p>
<p>201	lower bound of set range greater than higher bound</p>
<p>202	set element greater than MAX(SET) or less than 0</p>
<p>203	number too large</p>
<p>204	product too large</p>
<p>205	division by zero</p>
<p>206	sum too large</p>
<p>207	difference too large</p>
<p>208	overflow in arithmetic shift</p>
<p>209	case range too large</p>
<p>210	code too long</p>
<p>211	jump distance too large</p>
<p>213	too many cases in case statement</p>
<p>215	not enough registers: simplify expression</p>
<p>216	not enough floating_point registers: simplify expression</p>
<p>218	illegal value of parameter  (20 &lt;= p &lt; 256)</p>
<p>219	illegal value of parameter  (0 &lt;= p &lt; 16)</p>
<p>220	illegal value of parameter</p>
<p>221	too many pointers in a record</p>
<p>222	too many global pointers</p>
<p>223	too many record types</p>
<p>224	too many pointer types</p>
<p>226	too many global procedures</p>
<p>227	too many imported modules</p>
<p>228	too many exported structures</p>
<p>229	too many nested records for import</p>
<p>230	too many strings in module</p>
<p>233	record extension hierarchy too high</p>
<p>236	too many HALTs</p>
<p>240	identifier too long</p>
<p>241	string too long</p>
<p>242	address overflow</p>
<p>250	too many different global variables in module (combine into records)</p>
<p>252	too many local variables (32k max)</p>
<p>260	in_line code procedures must consist of even number of bytes</p>
<p>401	Toolbox CHAR data type not supported (use INTEGER) / Toolbox does not accept REAL or LONGREAL arguments</p>
<p>402	dynamic arrays may not be passed to this kind of procedure</p>
<p>403	type tests cannot be performed on untraced pointer types</p>
<p>404	Oberon cannot allocate storage for untraced pointer types; use the memory manager function _NewPtr instead</p>
<p>501	SIZE function not portable (result is machine dependent)</p>
<p>502	SYSTEM is not portable (results of SYSTEM-calls are machine dependent)</p>
<p>503	import of code-procedures not portable</p>
<p>504	methods not implemented</p>

<b></b><p><b>3.  Warnings</b> (reported by Compiler or by Analyzer)</p>
</font><font face="Times">
</font><font face="Geneva"><p>301	implicit type cast</p>
<p>302	guarded variable can be side_effected</p>
<p>303	open array (or pointer to array) containing pointers</p>
<p>801	destination in assignment already has this value</p>
<p>900	never used</p>
<p>901	never set</p>
<p>902	used before set</p>
<p>903	set but never used</p>
<p>904	used as varpar, possibly not set</p>
<p>905	also declared in outer scope</p>
<p>906	access/assignment to intermediate</p>
<p>907	redefinition</p>
<p>908	new definition</p>
<p>909	statement after RETURN/EXIT</p>
<p>910	for loop variable set</p>
<p>911	implied type guard in record assignment</p>
<p>912	call might depend on evaluation sequence of params.</p>
<p>1000+	spurious compiler misbehaviour, please notify</p></font>

</body></html>